[{"name":"Http.Detailed","comment":" Create HTTP requests with more detailed responses.\n\nThe metadata and original body of an HTTP response are often very useful!\nMaybe your server returns a useful error message you'd like to try and decode,\nor you want to access the header of a successful response.\n\nUnfortunately, this information is discarded in the default [`Http`][http] package's responses.\n\n[http]: https://package.elm-lang.org/packages/elm/http/2.0.0\n\n\n# Example\n\nCreate an HTTP request like you normally would -\njust use this module's [`expect`](#expect) functions instead of the ones from the default package.\n\n    import Http\n    import Http.Detailed\n\n\n    type Msg\n        = GotText (Result (Http.Detailed.Error String) ( String, Http.Metadata ))\n        | ...\n\n\n    -- Send a request\n    Http.get\n        { url = \"https://elm-lang.org/assets/public-opinion.txt\"\n        , expect = Http.Detailed.expectString GotText\n        }\n\nIf a successful response is received, the a `Tuple` containing the expected body and the metadata is returned.\nYou might need to access a header from the metadata!\n\nIn case of an error, a custom [`Error`](#Error) type is returned which keeps the metadata and body around if applicable,\nrather than discarding them. You might want to try and decode the error message!\n\nYour update function might look a bit like this:\n\n    update msg model =\n        case msg of\n            GotText detailedResponse ->\n                case detailedResponse of\n                    Ok (text, metadata ) ->\n                        -- Do something with the metadata if you need!\n\n                    Err error ->\n                        case error of\n                            Http.Detailed.BadStatus metadata body statusCode ->\n                                -- Try to decode the body - it might be a useful error message!\n\n                            Http.Detailed.Timeout ->\n                                -- No metadata is given here - the request timed out\n\n                            ...\n\n            ...\n\n\n# Expect\n\nExactly like the `expect` functions from [`Http`][http], but with a more detailed `Result`.\n\nOn a successful response, return a `Tuple` containing the expected body and the metadata.\nYou might need to access a header from the metadata!\n\nOn an error, returns our custom [`Error`](#Error) type which keeps the metadata and body around if applicable.\nYou might want to try and decode the error message!\n\nA modified version of the examples from the default [`Http`][http] package are included for each function,\nbut you should be familiar with making an HTTP request using the default package first!\n\n[http]: https://package.elm-lang.org/packages/elm/http/2.0.0\n\n@docs expectString, expectJson, expectBytes, expectWhatever, Error\n\n\n# Transform\n\nTransform an [`Http.Response`][httpResponse] value into the respective `Result` that is returned in each [`expect`](#Expect) function.\nFor example, this can be used with [`Mock`](../Http-Mock) to mock a response while using `Detailed` to handle responses:\n\n    import Http\n    import Http.Detailed\n    import Http.Mock\n\n\n    type Msg\n        = GotText (Result (Http.Detailed.Error String) ( String, Http.Metadata ))\n        | ...\n\n\n    -- Mock a request\n    Http.get\n        { url = \"https://fakeurl.com\"\n        , expect = Http.Mock.expectStringResponse Http.Timeout_ GotText Http.Detailed.responseToString\n        }\n\n[http]: https://package.elm-lang.org/packages/elm/http/2.0.0\n[httpResponse]: https://package.elm-lang.org/packages/elm/http/2.0.0/Http#Response\n\n@docs responseToString, responseToJson, responseToBytes, responseToWhatever\n\n","unions":[{"name":"Error","comment":" Our custom error type. Similar to [`Http.Error`][httpError], but keeps the metadata and body around\nin `BadStatus` and `BadBody` rather than discarding them. Maybe your API gives a useful error message you want to decode!\n\nThe type of the `body` depends on which `expect` function you use.\n\n  - [`expectJson`](#expectJson) and [`expectString`](#expectJson) will return a `String` body\n  - [`expectWhatever`](#expectWhatever) and [`expectBytes`](#expectBytes) will return a `Bytes` body.\n\nThe `BadBody` state will only be entered when using [`expectJson`](#expectJson) or [`expectBytes`](#expectBytes).\n\n[httpError]: https://package.elm-lang.org/packages/elm/http/2.0.0/Http#Error\n\n","args":["body"],"cases":[["BadUrl",["String.String"]],["Timeout",[]],["NetworkError",[]],["BadStatus",["Http.Metadata","body","Basics.Int"]],["BadBody",["Http.Metadata","body","String.String"]]]}],"aliases":[],"values":[{"name":"expectBytes","comment":" Expect the response body to be binary data, and try to decode it.\n\n    import Bytes exposing (Bytes)\n    import Bytes.Decode\n    import Http\n    import Http.Detailed\n\n    type Msg\n        = GotData (Result (Http.Detailed.Error Bytes) Data)\n\n    getData : Cmd Msg\n    getData =\n        Http.get\n            { url = \"/data\"\n            , expect = Http.Detailed.expectBytes GotData dataDecoder\n            }\n\n    dataDecoder : Bytes.Decode.Decoder Data\n\n    -- This is a Bytes decoder ...\n\nOn success, return the a tuple containing the decoded body and the metadata. On error, return our custom [`Error`](#Error) type.\n\nIf the Bytes decoder fails, you get a `BadBody` error that just indicates that\n_something_ went wrong. You can try to debug by taking a look at the\nbytes you are getting in the browser DevTools or something.\n\n","type":"(Result.Result (Http.Detailed.Error Bytes.Bytes) ( a, Http.Metadata ) -> msg) -> Bytes.Decode.Decoder a -> Http.Expect msg"},{"name":"expectJson","comment":" Expect the response body to be JSON, and try to decode it.\n\n    import Http\n    import Http.Detailed\n    import Json.Decode exposing (Decoder, field, string)\n\n    type Msg\n        = GotGif (Result (Http.Detailed.Error String) String)\n\n    getRandomCatGif : Cmd Msg\n    getRandomCatGif =\n        Http.get\n            { url = \"https://api.giphy.com/v1/gifs/random?api_key=dc6zaTOxFJmzC&tag=cat\"\n            , expect = Http.Detailed.expectJson GotGif gifDecoder\n            }\n\n    gifDecoder : Decoder String\n    gifDecoder =\n        field \"data\" (field \"image_url\" string)\n\nOn success, return a `Tuple` containing the decoded body and the metadata. On error, return our custom [`Error`](#Error) type.\n\nIf the JSON decoder fails, you get a `BadBody` error that tries to explain what went wrong.\n\n","type":"(Result.Result (Http.Detailed.Error String.String) ( a, Http.Metadata ) -> msg) -> Json.Decode.Decoder a -> Http.Expect msg"},{"name":"expectString","comment":" Expect the response body to be a `String`.\n\n    import Http\n    import Http.Detailed\n\n    type Msg\n        = GotText (Result (Http.Detailed.Error String) String)\n\n    getPublicOpinion : Cmd Msg\n    getPublicOpinion =\n        Http.get\n            { url = \"https://elm-lang.org/assets/public-opinion.txt\"\n            , expect = Http.Detailed.expectString GotText\n            }\n\nOn success, return a `Tuple` containing the body as a `String` and the metadata. On error, return our custom [`Error`](#Error) type.\n\nWhen using this, the error will never be of type `BadBody`.\n\n","type":"(Result.Result (Http.Detailed.Error String.String) ( String.String, Http.Metadata ) -> msg) -> Http.Expect msg"},{"name":"expectWhatever","comment":" Expect the response body to be whatever. It does not matter. Ignore it!\n\n    import Http\n    import Http.Extras\n\n    type Msg\n        = Uploaded (Result (Http.Extras.Error Bytes) ())\n\n    upload : File -> Cmd Msg\n    upload file =\n        Http.post\n            { url = \"/upload\"\n            , body = Http.fileBody file\n            , expect = Http.Extras.expectWhatever Uploaded\n            }\n\nThe server may be giving back a response body, but we do not care about it.\n\nOn error, return our custom [`Error`](#Error) type. It will never be `BadBody`.\n\n","type":"(Result.Result (Http.Detailed.Error Bytes.Bytes) () -> msg) -> Http.Expect msg"},{"name":"responseToBytes","comment":" ","type":"Bytes.Decode.Decoder a -> Http.Response Bytes.Bytes -> Result.Result (Http.Detailed.Error Bytes.Bytes) ( a, Http.Metadata )"},{"name":"responseToJson","comment":" ","type":"Json.Decode.Decoder a -> Http.Response String.String -> Result.Result (Http.Detailed.Error String.String) ( a, Http.Metadata )"},{"name":"responseToString","comment":" ","type":"Http.Response String.String -> Result.Result (Http.Detailed.Error String.String) ( String.String, Http.Metadata )"},{"name":"responseToWhatever","comment":" ","type":"Http.Response Bytes.Bytes -> Result.Result (Http.Detailed.Error Bytes.Bytes) ()"}],"binops":[]},{"name":"Http.Extras","comment":" Convenience functions for creating HTTP requests and interpreting an HTTP response.\n\n\n# Requests\n\nHelpers for creating HTTP requests.\n\n@docs Request, listToQuery, listToHeaders\n\n\n# Responses\n\nHelpers for interpreting an [`Http.Response`][httpResponse] value.\n\n[httpResponse]: https://package.elm-lang.org/packages/elm/http/2.0.0/Http#Response\n\n\n## Expect\n\n[`expectRawString`](#expectRawString) and [`expectRawBytes`](#expectRawBytes) are convenience functions for helping you build your own custom, advanced handlers for interpreting an Http response.\nThese functions return an [`Http.Response`][httpResponse] wrapped in a Result, where the `Result` will _**always**_ be `Ok`. Handle the [`Http.Response`][httpResponse] however you'd like!\n\n**Note:** These functions will likely be removed - they don't seem too useful.\n\n@docs expectRawString, expectRawBytes\n\n\n## Transform\n\nTransform an [`Http.Response`][httpResponse] value into the respective `Result` that is returned in each `expect` function from [`Http`][http].\n\n[http]: https://package.elm-lang.org/packages/elm/http/2.0.0\n[httpResponse]: https://package.elm-lang.org/packages/elm/http/2.0.0/Http#Response\n\n@docs responseToString, responseToJson, responseToBytes, responseToWhatever\n\n\n## Getters\n\nConvenience functions for extracting information like the header, status code, url, etc. from a [`Http.Response`][httpResponse] value.\nOn an error, a short string will be returned describing why the error occurred. For example:\n\n    getStatusCode Http.Timeout_\n        == Err \"Timeout\"\n\nThese functions are primarily concerned with accessing the metadata of a response.\nSo, these functions will return a successful `Result` if the response is `GoodStatus_` or `BadStatus_`.\nOtherwise, the `Result` will be an error.\n\n[httpResponse]: https://package.elm-lang.org/packages/elm/http/2.0.0/Http#Response\n\n@docs getUrl, getStatusCode, getStatusText, getHeaders, getMetadata, getBody, isSuccess\n\n","unions":[],"aliases":[{"name":"Request","comment":" The type that needs to be passed into [`Http.request`](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#request).\nIt's never actually defined as a type in the default package, so this is just the type definition for it.\n","args":["msg"],"type":"{ method : String.String, headers : List.List Http.Header, url : String.String, body : Http.Body, expect : Http.Expect msg, timeout : Maybe.Maybe Basics.Float, tracker : Maybe.Maybe String.String }"}],"values":[{"name":"expectRawBytes","comment":" ","type":"(Result.Result Http.Error (Http.Response Bytes.Bytes) -> msg) -> Http.Expect msg"},{"name":"expectRawString","comment":" ","type":"(Result.Result Http.Error (Http.Response String.String) -> msg) -> Http.Expect msg"},{"name":"getBody","comment":" ","type":"Http.Response body -> Result.Result String.String body"},{"name":"getHeaders","comment":" ","type":"Http.Response body -> Result.Result String.String (Dict.Dict String.String String.String)"},{"name":"getMetadata","comment":" ","type":"Http.Response body -> Result.Result String.String Http.Metadata"},{"name":"getStatusCode","comment":" ","type":"Http.Response body -> Result.Result String.String Basics.Int"},{"name":"getStatusText","comment":" ","type":"Http.Response body -> Result.Result String.String String.String"},{"name":"getUrl","comment":" Note that this only tries to return the url from the metadata - it does not return the url if\nthe response is `BadUrl_`\n","type":"Http.Response body -> Result.Result String.String String.String"},{"name":"isSuccess","comment":" Returns the status code if 200 <= status code < 300\n","type":"Http.Response body -> Result.Result String.String Basics.Int"},{"name":"listToHeaders","comment":" Convenience function to generate a list of [`Http.Header`](https://package.elm-lang.org/packages/elm/http/2.0.0/Http#Header)\nfrom a list of `( String, String )`.\n\n    generateHeaders [ ( \"Max-Forwards\", \"10\" ), ( \"Authorization\", \"Basic pw123\" ) ]\n        == [ Http.Header \"Max-Forwards\" \"10\", Http.Header \"Authorization\" \"Basic pw123\" ]\n\n","type":"List.List ( String.String, String.String ) -> List.List Http.Header"},{"name":"listToQuery","comment":" Convenience function to generate a [percent-encoded](https://tools.ietf.org/html/rfc3986#section-2.1) query string from a list of `( String, String )`.\n\n    generateQuery [ ( \"foo\", \"abc 123\" ), ( \"bar\", \"xyz\" ) ]\n        == \"?foo=abc%20123&bar=xyz\"\n\n**Note:** It seems that this function should not be a part of this library, and it would be more appropriate in something\nlike Url.Extras. I only have this function here for now because it is something I use frequently...\n\n","type":"List.List ( String.String, String.String ) -> String.String"},{"name":"responseToBytes","comment":" ","type":"Bytes.Decode.Decoder a -> Http.Response Bytes.Bytes -> Result.Result Http.Error a"},{"name":"responseToJson","comment":" ","type":"Json.Decode.Decoder a -> Http.Response String.String -> Result.Result Http.Error a"},{"name":"responseToString","comment":" ","type":"Http.Response String.String -> Result.Result Http.Error String.String"},{"name":"responseToWhatever","comment":" ","type":"Http.Response Bytes.Bytes -> Result.Result Http.Error ()"}],"binops":[]},{"name":"Http.Mock","comment":" Mock an HTTP response from within Elm.\n\nSpecify exactly what you'd like the response of an HTTP request to be.\nThe actual response of the HTTP request is ignored - the response will be exactly what you want to be mocked!\n\nHere's are some examples of how this can be useful!\n\n\n# Testing your code\n\nNot sure how your code handles an HTTP request that results in a `Timeout`? Test it by mocking a Timeout response!\n\n    import Http\n    import Http.Mock\n\n    type Msg\n        = MyResponseHandler (Result Http.Error String)\n\n    testTimeout =\n        Http.get\n            { url = \"https://fakeurl.com\"\n            , expect = Http.Mock.expectString Http.Timeout_ MyResponseHandler\n            }\n\nYour update logic doesn't change - mock a `Timeout` response and make sure your program handles it correctly!\nNotice that we put in a dummy URL here - It doesn't matter what type of request you make response of the request will be exactly what you specify.\n\n\n# Mocking an API\n\nNeed to quickly mock an API locally? Don't waste time setting up a fake HTTP server for testing - just mock the response directly from within Elm!\n\n    import Http\n    import Http.Mock\n\n    type Msg\n        = MyResponseHandler (Result Http.Error String)\n\n    -- This is our mocked response.\n    -- You would actually put metadata and a body!\n    mockResponse =\n        Http.GoodStatus_ <metadata> <body>\n\n    sendRequestWithMockedResponse =\n        Http.get\n            { url = \"https://fakeurl.com\"\n            , expect = Http.Mock.expectString mockResponse MyResponseHandler\n            }\n\nAgain, your update logic should not change, and it doesn't matter what type of request you make - the response is discarded in favor of the mocked response.\n\n\n# Mock\n\nVery similar to the `expect` functions from the default [Http][http] package, but you specify exactly what you want the response to be.\n\n[http]: https://package.elm-lang.org/packages/elm/http/2.0.0\n\n@docs expectString, expectJson, expectBytes, expectWhatever, expectStringResponse, expectBytesResponse\n\n","unions":[],"aliases":[],"values":[{"name":"expectBytes","comment":" ","type":"Http.Response Bytes.Bytes -> (Result.Result Http.Error a -> msg) -> Bytes.Decode.Decoder a -> Http.Expect msg"},{"name":"expectBytesResponse","comment":" ","type":"Http.Response Bytes.Bytes -> (Result.Result x a -> msg) -> (Http.Response Bytes.Bytes -> Result.Result x a) -> Http.Expect msg"},{"name":"expectJson","comment":" ","type":"Http.Response String.String -> (Result.Result Http.Error a -> msg) -> Json.Decode.Decoder a -> Http.Expect msg"},{"name":"expectString","comment":" ","type":"Http.Response String.String -> (Result.Result Http.Error String.String -> msg) -> Http.Expect msg"},{"name":"expectStringResponse","comment":" ","type":"Http.Response String.String -> (Result.Result x a -> msg) -> (Http.Response String.String -> Result.Result x a) -> Http.Expect msg"},{"name":"expectWhatever","comment":" ","type":"Http.Response Bytes.Bytes -> (Result.Result Http.Error () -> msg) -> Http.Expect msg"}],"binops":[]}]